////////////////////////////////////////////////////////////////////////////////////
//C#, C++, C++/CLI DIFFERENCES
////////////////////////////////////////////////////////////////////////////////////

====================================================================================
VARIABLE DIFFERENCES
====================================================================================

VALUE VARIABLE TYPES:
[C# ] Structs, basic data types created on stack/register
[CLI] Classes, structs, basic data types created on stack/register
[C++] Classes, structs, basic data types created on stack/register

REFERENCE VARIABLE TYPES:
[C# ] Classes created on heap
[CLI] Classes, structs, basic data types created on heap
[C++] Classes, structs, basic data types created on heap

CREATING REFERENCE TYPES:
[C# ] Uses new, garbage collected, can't be overloaded, array form, no placement form
[CLI] Uses gcnew, garbage collected, can't be overloaded, no array form, no placement form
[C++] Uses new, manual deletion, can be overloaded, array form, placement form

PARENT-CHILD SCOPE: int myInt = 2; { int myInt = 1; }
[C# ] If variable is in parent scope it cannot be redeclared in child scope
[CLI] As long as scope seperates variables, it can be redeclared
[C++] As long as scope seperates variables, it can be redeclared

STAND-ALONE VARIABLES:
[C# ] Not allowed. Must have variables inside class/struct.
[CLI] Allowed
[C++] Allowed

FLOATING EXPRESSIONS: 2+4;
[C# ] Not allowed, must be assigned to something
[CLI] Allowed
[C++] Allowed

STRING CONCATONATION: string str = "one"+1;
[C# ] Will auto convert the number to a string during concatonation
[CLI] Depends on whether using std::string or System::string
[C++] Won't auto convert number to string

NAMESPACES:
[C# ] Cannot be anon, cannot contain variables/methods
[CLI] Can be anon, can contain variables/methods
[C++] Can be anon, can contain variables/methods

#DEFINE:
[C# ] Must be before any code, cannot define variables/expressions, uses #if
[CLI] Can be anywhere, can define variables/expressions, uses #ifdef
[C++] Can be anywhere, can define variables/expressions, uses #ifdef

DOWNCASTING: int myInt = 1.0/2.0;
[C# ] No downcasting, Compile error, only implicitly converts if range can fit in new variable
[CLI] Downcasting okay, Compile warning, implicitly converts no matter what
[C++] Downcasting okay, Compile warning, implicitly converts no matter what

VALUE TO BOOL CONVERSION: if(myNumber){}
[C# ] Cannot accept a number into a bool; cannot use number as bool in if-statements
[CLI] Can accept a number into a bool; can use number as bool in if-statements
[C++] Can accept a number into a bool; can use number as bool in if-statements

SWITCH STATEMENTS:
[C# ] Can use strings in a switch statement, cannot fall through to next case
[CLI] Cannot use strings in a switch statement, can fall through to next case
[C++] Cannot use strings in a switch statement, can fall through to next case

PASSING BY-REF:
[C# ] Cannot return a reference, passes in reference with out/ref, tracks changes to objects address
[CLI] Can return a reference and passes in reference with %, tracks changes to objects address
[C++] Can return a reference and passes in reference with &, doesn't track changes objects address

====================================================================================
CLASS/STRUCT DIFFERENCES
====================================================================================

C# CLASS OBJECT CREATION:
1) Derived member Field Initialisaters called
2) Base member Field Initialisaters called
3) Base Constructor Body called
4) Derived Constructor Body called
5) Derived Destructor called
6) Base Desctructor called

C++ CLASS OBJECT CREATION:
1) Base Initialisation List called
2) Base Constructor Body called
3) Derived Initialisation List called
4) Derived Constructor Body called
5) Derived Destructor called
6) Base Desctructor called

C++/CLI CLASS OBJECT CREATION:
1)
2)
3)

STRUCT/CLASS TYPES:
[C# ] Structs value only, Class reference only
[CLI] Both allow value/reference types
[C++] Both allow value/reference types

USER-DEFINED CONSTRUCTOR/DESTRUCTOR:
[C# ] Value-type can't have, Reference type can
[CLI] Value-type can't have, Reference type can
[C++] Reference/Value-types both have

IMPLICIT MEMBERS:
[C# ] Struct/Class: default constructor/destrutor, System.Object members, operator==(Class Only)
[CLI] Struct/Class: default constructor/destructor, System.Object members, operator==(Class Only)
[C++] Struct/Class: default constructor/destrutor, copy constructor, operator=, operator&

DEFAULT VISIBILITY:
[C# ] Struct is public, Class is internal, All members private
[CLI] Struct/Struct members is public, Class/Class members is private
[C++] Struct/Struct members is public, Class/Class members is private

STATIC CLASSES:
[C# ] static keyword used (can't have abstract sealed together) only holds static members/methods
[CLI] abstract sealed keywords used, only holds static members/methods
[C++] no keywords

INITIALISING STATIC MEMBERS:
[C# ] Initialised through Static constructor or when first used through field initialisation
[CLI] 
[C++] Initialised before main() called in cpp file

ACCESSING NAMESPACE/STATIC MEMBERS:
[C# ] Uses MyClass.MyStaticMethod();
[CLI] Uses MyClass::MyStaticMethod();
[C++] Uses MyClass::MyStaticMethod();

====================================================================================
INHERITANCE DIFFERENCES
====================================================================================

INHERITANCE
[C# ] Struct inherits interfaces, Class inherits one base/multiple interfaces, public inheritance
[CLI] Struct inherits interfaces, Class inherits one base/multiple interfaces, public inheritance
[C++] Struct inherits anything publically by default, Class inherits anything privately by default

INHERITANCE SUPPORT
[C# ] No MI (uses interfaces for MI), only public inheritance
[CLI] No MI (uses interfaces for MI), only public inheritance
[C++] Multiple Inheritance, private/protected inheritance support

SLICING:
[C# ] Slicing cannot occur as inheritance only occurs on reference types
[CLI] Slicing cannot occur as inheritance only occurs on reference types
[C++] Slicing can occur as inheritance occurs on reference and value types

INHERITED METHOD VISIBILITY:
[C# ] Inherited methods cannot be private; visibility must be the same between base/derived
[CLI] 
[C++] Inherited Methods can have any visibility; base/derived visibility doesn't have to match

PURE VIRTUAL METHODS/CLASS:
[C# ] Requires abstract keyword for class, makes all methods automatically virtual
[CLI] 
[C++] Requires virtual keyword on method, makes class automatically abstract

CALLING VIRTUAL METHOD IN CONSTRUCTOR:
[C# ] Dangerous to call virtual method in constructor; calls Derived version
[CLI] 
[C++] Dangerous to call virtual method in constructor; calls Base version



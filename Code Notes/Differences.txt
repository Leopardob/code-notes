////////////////////////////////////////////////////////////////////////////////////
//C#, C++, C++/CLI DIFFERENCES
////////////////////////////////////////////////////////////////////////////////////

====================================================================================
VARIABLE DIFFERENCES
====================================================================================

VALUE VARIABLE TYPES:
[C# ] Structs, basic data types created on stack/register
[CLI] Classes, structs, basic data types created on stack/register
[C++] Classes, structs, basic data types created on stack/register

REFERENCE VARIABLE TYPES:
[C# ] Classes created on heap
[CLI] Classes, structs, basic data types created on heap
[C++] Classes, structs, basic data types created on heap

CREATING REFERENCE TYPES:
[C# ] Uses new, garbage collected, can't be overloaded, array form, no placement form
[CLI] Uses gcnew, garbage collected, can't be overloaded, no array form, no placement form
[C++] Uses new, manual deletion, can be overloaded, array form, placement form

PARENT-CHILD SCOPE: int myInt = 2; { int myInt = 1; }
[C# ] If variable is in parent scope it cannot be redeclared in child scope
[CLI] As long as scope seperates variables, it can be redeclared
[C++] As long as scope seperates variables, it can be redeclared

STAND-ALONE VARIABLES:
[C# ] Not allowed. Must have variables inside class/struct.
[CLI] Allowed
[C++] Allowed

FLOATING EXPRESSIONS: 2+4;
[C# ] Not allowed, must be assigned to something
[CLI] Allowed
[C++] Allowed

STRING CONCATONATION: string str = "one"+1;
[C# ] Will auto convert the number to a string during concatonation
[CLI] Depends on whether using std::string or System::string
[C++] Won't auto convert number to string

NAMESPACES:
[C# ] Cannot be anon, cannot contain variables/methods
[CLI] Can be anon, can contain variables/methods
[C++] Can be anon, can contain variables/methods

INCLUDING LIBRARIES:
[C# ] using MyLibrary
[CLI] using MyLibrary and #include MyLibrary.h
[C++] #include MyLibrary.h

#DEFINE:
[C# ] Must be before any code, cannot define variables/expressions, uses #if
[CLI] Can be anywhere, can define variables/expressions, uses #ifdef
[C++] Can be anywhere, can define variables/expressions, uses #ifdef

DOWNCASTING: int myInt = 1.0/2.0;
[C# ] No downcasting, Compile error, only implicitly converts if range can fit in new variable
[CLI] Downcasting okay, Compile warning, implicitly converts no matter what
[C++] Downcasting okay, Compile warning, implicitly converts no matter what

VALUE TO BOOL CONVERSION: if(myNumber){}
[C# ] Cannot accept a number into a bool; cannot use number as bool in if-statements
[CLI] Can accept a number into a bool; can use number as bool in if-statements
[C++] Can accept a number into a bool; can use number as bool in if-statements

SWITCH STATEMENTS:
[C# ] Can use strings in a switch statement, cannot fall through to next case
[CLI] Cannot use strings in a switch statement, can fall through to next case
[C++] Cannot use strings in a switch statement, can fall through to next case

PASSING BY-REF:
[C# ] Cannot return a reference, passes in reference with out/ref, tracks changes to objects address
[CLI] Can return a reference and passes in reference with %, tracks changes to objects address
[C++] Can return a reference and passes in reference with &, doesn't track changes objects address

====================================================================================
CLASS/STRUCT DIFFERENCES
====================================================================================

C# CLASS OBJECT CREATION:
1) Derived member Field Initialisaters
2) Base member Field Initialisaters
3) Base Constructor Body
4) Derived Constructor Body
5) Derived Dispose or Derived Finaliser
6) Base Dispose or Base Finaliser

C++ CLASS OBJECT CREATION:
1) Base Initialisation List
2) Base Constructor Body
3) Derived Initialisation List
4) Derived Constructor Body
5) Derived Destructor
6) Base Desctructor

C++/CLI CLASS OBJECT CREATION:
1) Derived Initialisation List
2) Base Initialisation List
3) Base Constructor Body
4) Derived Constructor Body
5) Derived Destructor or Derived Finaliser
6) Base Desctructor or Base Finaliser

STRUCT/CLASS TYPES:
[C# ] Structs value only, Class reference only
[CLI] Both allow value/reference types
[C++] Both allow value/reference types

PREVENTED MEMBERS:
[C# ] Value-types can't have user defined default constructor, destructor
[CLI] Value-types can't have user defined default constructor, destructor, copy constructor, operator=
[C++] Static constructor

IMPLICIT MEMBERS:
[C# ] Struct/Class: default/static constructor, finaliser, System.Object members, operator==(Class Only)
[CLI] Struct/Class: default/static constructor, finaliser, System.Object members, operator==(Class Only)
[C++] Struct/Class: default constructor, destrutor, copy/move constructor, operator=, operator&

DEFAULT VISIBILITY:
[C# ] Struct is public, Class is internal, All members private
[CLI] Struct members is public, Class members is private, Overall struct/class is internal
[C++] Struct/Struct members is public, Class/Class members is private

VARIABLE AUTO-INITIALISATION
[C# ] Class members, local variables at start of method and not within block scope call default()
[CLI] Value-type members, Local variables at start of method and not within block scope initialised to 0
[C++] Static variables auto-initialised to 0

STATIC CLASSES:
[C# ] Static keyword used (can't have abstract sealed together) only holds static members/methods
[CLI] Abstract sealed keywords used, only holds static members/methods
[C++] No keywords

INITIALISING STATIC MEMBERS:
[C# ] Initialised through Static constructor or when first used through field initialisation
[CLI] Initialised through Static constructor, no field/cpp initialisation
[C++] Initialised before main() called in cpp file

OBJECT DELETION
[C# ] Destructor inherited as Dispose() and explicitly called or Finaliser called by GC.
[CLI] Destructor called when object on stack out of scope/delete used or Finaliser called by GC.
[C++] Destructor called when object on stack out of scope/delete used. No Finaliser.

CLASS ;
[C# ] Doesn't require ; at end of closing bracket
[CLI] Requires ; at end of closing bracket
[C++] Requires ; at end of closing bracket

====================================================================================
INHERITANCE DIFFERENCES
====================================================================================

INHERITANCE
[C# ] Struct inherits interfaces, Class inherits one base/multiple interfaces, public inheritance
[CLI] Struct inherits interfaces, Class inherits one base/multiple interfaces, public inheritance
[C++] Struct inherits anything publically by default, Class inherits anything privately by default

INHERITANCE SUPPORT
[C# ] No MI (uses interfaces for MI), only public inheritance
[CLI] No MI (uses interfaces for MI), only public inheritance
[C++] Multiple Inheritance, private/protected inheritance support

SLICING:
[C# ] Slicing cannot occur as inheritance only occurs on reference types
[CLI] Slicing cannot occur as inheritance only occurs on reference types
[C++] Slicing can occur as inheritance occurs on reference and value types

INHERITED METHOD VISIBILITY:
[C# ] Virtual methods cannot be private, visibility must be the same between base/derived
[CLI] Virtual Methods can have any visibility, Private virtual must be sealed. Derived must have same or higher visibility than base.
[C++] Virtual Methods can have any visibility, base/derived visibility doesn't have to match

PURE VIRTUAL METHODS/CLASS:
[C# ] Abstract methods require keyword for class, abstract methods are automatically virtual
[CLI] Abstract methods require keyword for class, abstract methods require virtual keyword
[C++] Creating a pure virtual function with virtual and = 0 makes class auto-abstract

CALLING VIRTUAL METHOD IN CONSTRUCTOR:
[C# ] Dangerous to call virtual method in constructor; calls Derived version
[CLI] Dangerous to call virtual method in constructor; calls Derived version
[C++] Dangerous to call virtual method in constructor; calls Base version

DESTRUCTOR INHERITANCE
[C# ] Always virtual (from auto-inheriting System::Object)
[CLI] Always virtual (from auto-inheriting System::Object)
[C++] Only virtual if inheriting from base class with virtual destructor


